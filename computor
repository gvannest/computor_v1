#!/usr/bin/env python3

import sys
import argparse

from equation import Equation


def ft_argparser():
	parser = argparse.ArgumentParser()
	parser.add_argument("input", type=str, help="Equation to be reduced and solved")
	parser.add_argument("-r", "--human_readable", action="store_true",
						help="Everything in the title.")
	parser.add_argument("-t", "--tree", action="store_true",
						help="Allows for vizualizing the tree in the terminal window.")
	parser.add_argument("-v", "--verbose", action="store_true",
						help="Prints out each calculation in reducing and solving the equation")
	parser.add_argument("-n", "--neg", action="store_true",
						help="Tries to solve for negative degrees")
	args = parser.parse_args()
	return args


def print_final_results(eq):
	if eq.delta is None:
		print("The unique solution to the equation is:")
		print(f"X = {eq.solution1}")
	elif eq.delta == 0:
		print("Discriminant is null. There is one double solution :")
		print(f"X = {eq.solution1}")
	elif eq.delta > 0:
		print("Discriminant is strictly positive. The two real solutions are:")
		print(f"X1 = {eq.solution1}\nX2 = {eq.solution2}")
	elif eq.delta < 0:
		print("Discriminant is strictly negative. The two complex solutions are:")
		print(f"X1 = {eq.solution1}\nX2 = {eq.solution2}")

	return None


def main(args):
	if not args.input:
		print("Error : please provide a valid string as argument.")
		sys.exit(0)
	eq = Equation(line=args.input, flag_h=args.human_readable, flag_t=args.tree, flag_n=args.neg, flag_v=args.verbose)
	eq.parsing_errors()
	eq.build_trees()
	eq.reduce_equation()
	if args.tree:
		print("\nTree before resolution")
		print("=================================================")
		Equation.ft_print_tree(eq.tree_for_printing)
	print(f"\nReduced form : {eq.reduced_str}")
	print(f"Polynomial degree : {eq.max_degree}")
	eq.solve_equation()
	print_final_results(eq)

	return None


if __name__ == "__main__":
	args = ft_argparser()
	main(args)
