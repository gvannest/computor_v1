#!/usr/bin/env python3

import sys
import argparse

from equation import Equation


def ft_argparser():
	parser = argparse.ArgumentParser()
	parser.add_argument("input", type=str, help="Equation to be reduced and solved")
	parser.add_argument("-r", "--human_readable", action="store_true",
						help="Everything in the title.")
	# parser.add_argument("-u", "--undetermined", action="store_true",
	# 					help="Undetermined mode, where the user can clarify undetermined facts")
	# parser.add_argument("-v", "--verbose", action="store_true",
	# 					help="Verbose mode. Outputs the rules leading to a particular conclusion")
	args = parser.parse_args()
	return args


def print_final_results(eq):
	if eq.delta is None:
		print("The unique solution to the equation is:")
		print(f"X = {eq.solution1}")
	elif eq.delta == 0:
		print("Discriminant is null. There is one double solution :")
		print(f"X = {eq.solution1}")
	elif eq.delta > 0:
		print("Discriminant is strictly positive. The two real solutions are:")
		print(f"X1 = {eq.solution1}\nX2 = {eq.solution2}")
	elif eq.delta < 0:
		print("Discriminant is strictly negative. The two complex solutions are:")
		print(f"X1 = {eq.solution1}\nX2 = {eq.solution2}")

	return None

def main(args):
	if not args.input:
		print("Error : please provide a valid string as argument.")
		sys.exit(0)
	eq = Equation(line=args.input, flag=args.human_readable)
	eq.parsing_errors()
	eq.build_trees()
	eq.reduce_equation()
	print(f"Reduced form : {eq.reduced_str}")
	print(f"Polynomial degree : {eq.degree}")
	eq.solve_equation()
	print_final_results(eq)

	return None


if __name__ == "__main__":
	args = ft_argparser()
	main(args)
